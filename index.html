<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parameterized Tray - Pro Segment Designer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Thêm thư viện STLExporter -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/STLExporter.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@300;400;500;600;700&display=swap');
        body { font-family: 'Plus Jakarta Sans', sans-serif; background-color: #1a1a1a; color: #f4f4f5; margin: 0; overflow: hidden; }
        .floating-panel { background: rgba(30, 30, 30, 0.7); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.1); box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4); }
        .input-group { background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); transition: all 0.2s ease; }
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #ffffff; cursor: pointer; margin-top: -6px; box-shadow: 0 0 10px rgba(255,255,255,0.3); border: none; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: rgba(255,255,255,0.2); border-radius: 2px; }
        .view-label { position: absolute; top: 1rem; left: 1rem; background: rgba(255,255,255,0.1); padding: 6px 14px; border-radius: 10px; font-size: 10px; text-transform: uppercase; letter-spacing: 0.1em; font-weight: 700; color: rgba(255,255,255,0.8); z-index: 20; pointer-events: none; border: none; }
        #main-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .viewport-placeholder { position: relative; flex: 1; z-index: 2; }
        .dim-label { position: absolute; font-size: 11px; font-weight: 800; color: #ffffff; z-index: 2000; background: #27272a; padding: 4px 10px; border-radius: 6px; white-space: nowrap; box-shadow: 0 4px 12px rgba(0,0,0,0.8); cursor: pointer; pointer-events: auto; transition: transform 0.15s, background 0.2s; border: 1px solid rgba(255,255,255,0.2); user-select: none; }
        .dim-label:hover { background: #3b82f6; border-color: #ffffff; transform: scale(1.1); }
        .dim-input { width: 50px; background: #fff; color: #000; border: none; border-radius: 4px; font-size: 12px; font-weight: 800; text-align: center; outline: none; padding: 2px 0; }
        #add-indicator { position: fixed; width: 36px; height: 36px; background: #18181b; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 24px; pointer-events: none; z-index: 100; opacity: 0; transform: scale(0); transition: opacity 0.2s, transform 0.2s; box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
        #add-indicator.active { opacity: 1; transform: scale(1); }
        #add-indicator.remove-confirm { background: #ef4444; color: white; box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4); }
        #add-indicator.move { background: #3b82f6; color: white; font-size: 16px; }
        #preview-line { position: fixed; background: #3b82f6; pointer-events: none; z-index: 90; display: none; box-shadow: 0 0 10px rgba(59, 130, 246, 0.5); }
        #global-dim-input { position: fixed; z-index: 9999; width: 60px; height: 26px; background: #fff; color: #000; border: 2px solid #3b82f6; border-radius: 6px; font-size: 11px; font-weight: 800; text-align: center; outline: none; padding: 0; display: none; box-shadow: 0 10px 25px rgba(0,0,0,0.5); transform: translate(-50%, -50%); font-family: 'Plus Jakarta Sans', sans-serif; }
        .dim-label-3d { background: rgba(24, 24, 27, 0.85); border: 1px solid rgba(255,255,255,0.3); color: #fff !important; backdrop-filter: blur(8px); box-shadow: 0 4px 12px rgba(0,0,0,0.5); }
        .dim-label-3d input { color: #000 !important; }
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }

        /* Tutorial Overlay Styles */
        #tutorial-overlay { position: fixed; inset: 0; pointer-events: none; z-index: 9999; display: none; }
        .tutorial-active #tutorial-overlay { display: block; }

        .tutorial-skip-btn { position: fixed; bottom: 30px; right: 30px; background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); color: rgba(255, 255, 255, 0.7); padding: 8px 16px; border-radius: 20px; font-size: 12px; font-weight: 600; cursor: pointer; pointer-events: auto; transition: all 0.2s; text-transform: uppercase; letter-spacing: 0.05em; z-index: 10003; }
        .tutorial-skip-btn:hover { background: rgba(255, 255, 255, 0.2); color: white; transform: scale(1.05); }

        .tutorial-blob { position: absolute; width: 140px; transition: all 0.5s ease-out; z-index: 10001; pointer-events: none; }
        /* Soft Yellow color #fef08a (similar to sticky note/Whisk) */
        .tutorial-blob svg path { fill: #fef08a; stroke: #fff; stroke-width: 3px; filter: drop-shadow(0 0 4px rgba(255,255,255,0.8)); }
        .tutorial-blob svg { width: 100%; height: auto; filter: drop-shadow(0px 8px 24px rgba(0,0,0,0.15)); }
        .tutorial-text { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; text-align: center; padding: 25px; font-family: 'Patrick Hand', cursive; font-size: 16px; line-height: 1.3; color: #18181b; font-weight: 600; transform: rotate(-2deg); pointer-events: none; }

        .tutorial-arrow { position: absolute; width: 60px; height: 60px; transition: all 0.5s ease-out; z-index: 10000; }
        .tutorial-arrow svg { width: 100%; height: 100%; stroke: #fff; filter: drop-shadow(0 0 4px rgba(255,255,255,0.8)); }

        .ghost-cursor { position: absolute; width: 32px; height: 32px; pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 10002; transform-origin: 0 0; }
        /* Neon White Glow for Ghost Cursor */
        .ghost-cursor svg { filter: drop-shadow(0 0 5px #fff) drop-shadow(0 0 10px #fff); }

        .ghost-divider { position: absolute; background: rgba(59, 130, 246, 0.5); pointer-events: none; opacity: 0; z-index: 9998; border-radius: 2px; }

        /* Animations - Slowed down (approx 2x duration) */
        @keyframes cursor-scan-h { /* Horizontal scan (Right edge) */
            0% { opacity: 0; transform: translate(0, 0); }
            10% { opacity: 1; transform: translate(0, 0); }
            50% { transform: translate(0, 150px); }
            90% { transform: translate(0, 0); }
            100% { opacity: 0; transform: translate(0, 0); }
        }
        @keyframes cursor-scan-v { /* Vertical scan (Bottom edge) */
            0% { opacity: 0; transform: translate(0, 0); }
            10% { opacity: 1; transform: translate(0, 0); }
            50% { transform: translate(150px, 0); }
            90% { transform: translate(0, 0); }
            100% { opacity: 0; transform: translate(0, 0); }
        }

        @keyframes cursor-drag-shadow {
             0% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
            10% { opacity: 1; transform: translate(-50%, -50%) scale(1); } /* Move to start */
            20% { transform: translate(-50%, -50%) scale(0.9); } /* Grab */
            70% { transform: translate(50px, -50%) scale(0.9); } /* Drag */
            90% { transform: translate(50px, -50%) scale(1); } /* Release */
            100% { opacity: 0; transform: translate(50px, -50%) scale(1); }
        }
        @keyframes divider-drag-shadow {
             0% { opacity: 0; transform: translate(-50%, -50%); }
            10% { opacity: 0; transform: translate(-50%, -50%); }
            20% { opacity: 1; transform: translate(-50%, -50%); } /* Appear */
            70% { transform: translate(50px, -50%); } /* Move */
            90% { opacity: 0; transform: translate(50px, -50%); } /* Disappear */
            100% { opacity: 0; transform: translate(50px, -50%); }
        }

        @keyframes cursor-click-delete-slow {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
            10% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            30% { transform: translate(-50%, -50%) scale(0.8); } /* Click 1 */
            50% { transform: translate(-50%, -50%) scale(1); }
            60% { transform: translate(-50%, -50%) scale(1); } /* Pause */
            70% { transform: translate(-50%, -50%) scale(0.8); } /* Click 2 */
            90% { transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body class="relative h-screen w-screen">
    <canvas id="main-canvas"></canvas>

    <!-- Tutorial Overlay -->
    <button id="tut-skip" class="tutorial-skip-btn">Skip Tutorial</button>
    <div id="tutorial-overlay">
        <div id="tut-blob" class="tutorial-blob">
            <svg viewBox="0 0 200 150" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M22.5 45.5C8.5 65.5 -5.5 105.5 22.5 125.5C50.5 145.5 100.5 155.5 145.5 135.5C190.5 115.5 205.5 65.5 185.5 35.5C165.5 5.5 100.5 -15.5 55.5 15.5C35.5 28.5 22.5 45.5 22.5 45.5Z" fill="#FFD700"/>
            </svg>
            <div id="tut-text" class="tutorial-text">Start here!</div>
        </div>
        <div id="tut-arrow" class="tutorial-arrow">
            <svg viewBox="0 0 100 100" fill="none" stroke="black" stroke-width="5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M10 90 Q 50 50 80 20 M 80 20 L 50 20 M 80 20 L 80 50" />
            </svg>
        </div>
        <div id="ghost-cursor" class="ghost-cursor">
            <svg viewBox="0 0 24 24" fill="white" stroke="black" stroke-width="2" xmlns="http://www.w3.org/2000/svg">
                <path d="M3 3L10.07 19.97L12.58 12.58L19.97 10.07L3 3Z" />
            </svg>
        </div>
        <div id="ghost-divider" class="ghost-divider"></div>
    </div>

    <div id="add-indicator">+</div>
    <div id="preview-line"></div>
    <input type="number" id="global-dim-input" aria-label="Global Dimension Editor" />
    <div class="absolute inset-0 z-10 flex flex-col pointer-events-none">
        <header class="w-full p-6 flex justify-between items-center pointer-events-none">
            <div class="flex items-center gap-3 pointer-events-auto">
                <div class="w-10 h-10 bg-white rounded-2xl flex items-center justify-center shadow-xl"><div class="w-5 h-5 bg-black rotate-45 rounded-sm"></div></div>
                <div><h1 class="font-bold text-lg leading-none text-white">Parameterized Tray</h1><p class="text-[10px] text-zinc-400 font-medium uppercase tracking-widest mt-1">Smart Editing Mode</p></div>
            </div>
            <div class="flex gap-3 pointer-events-auto">
                <button id="export-btn" class="bg-white text-black font-bold px-6 py-3 rounded-2xl text-sm flex items-center gap-2 hover:scale-105 active:scale-95 transition-all shadow-lg hover:bg-zinc-200"><i data-lucide="download" class="w-4 h-4"></i>Export STL</button>
            </div>
        </header>
        <main id="viewports-container" class="flex-1 flex flex-col md:flex-row">
            <div id="view-3d-placeholder" class="viewport-placeholder border-b md:border-b-0 md:border-r border-white/10 pointer-events-auto cursor-grab active:cursor-grabbing"><div class="view-label">3D View</div><div id="dim-container-3d" class="absolute inset-0 pointer-events-none overflow-hidden" style="z-index: 50;"></div></div>
            <div id="view-top-placeholder" class="viewport-placeholder pointer-events-auto"><div class="view-label">Top View</div><div id="dim-container" class="absolute inset-0 pointer-events-none overflow-hidden" style="z-index: 50;"></div></div>
        </main>
        <div class="w-full p-4 md:p-8 flex justify-center pointer-events-none">
            <div class="floating-panel rounded-[2.5rem] p-4 md:p-8 flex flex-col md:flex-row gap-8 items-center justify-between pointer-events-auto w-full max-w-4xl">
                <div class="flex gap-4 items-center">
                    <div class="flex flex-col gap-1"><span class="text-[10px] text-zinc-400 font-bold uppercase tracking-wider ml-1">Dimensions (mm)</span><div class="flex gap-2"><div class="input-group px-3 py-2 rounded-xl flex items-center gap-2"><label for="dim-l" class="text-[10px] text-zinc-400 font-bold cursor-pointer" title="Length">L</label><input type="number" id="dim-l" aria-label="Length" value="120" class="w-12 bg-transparent text-sm font-semibold outline-none text-center text-white"></div><div class="input-group px-3 py-2 rounded-xl flex items-center gap-2"><label for="dim-w" class="text-[10px] text-zinc-400 font-bold cursor-pointer" title="Width">W</label><input type="number" id="dim-w" aria-label="Width" value="120" class="w-12 bg-transparent text-sm font-semibold outline-none text-center text-white"></div><div class="input-group px-3 py-2 rounded-xl flex items-center gap-2"><label for="dim-h" class="text-[10px] text-zinc-400 font-bold cursor-pointer" title="Height">H</label><input type="number" id="dim-h" aria-label="Height" value="40" class="w-12 bg-transparent text-sm font-semibold outline-none text-center text-white"></div></div></div>
                </div>
                <div class="w-px h-10 bg-white/10 mx-2"></div>
                <div class="flex flex-col gap-1 w-32"><div class="flex justify-between items-center mb-1"><label for="radius" class="text-[10px] text-zinc-400 font-bold uppercase tracking-wider cursor-pointer">Corner Radius</label><span id="radius-val" class="text-[10px] text-white font-bold">8mm</span></div><input type="range" id="radius" aria-label="Corner Radius" min="2" max="30" value="8" step="1"></div>
                <div class="w-px h-10 bg-white/10 mx-2"></div>
                <div class="flex flex-col gap-1 flex-1"><div class="flex justify-between items-center mb-1"><span class="text-[10px] text-zinc-400 font-bold uppercase tracking-wider ml-1">Dividers</span><button id="clear-dividers" class="text-[9px] text-red-400 hover:text-red-300 uppercase font-bold tracking-tighter">Clear All</button></div><div class="text-xs text-zinc-400 font-medium" id="divider-stats">Vert: 0 | Horiz: 0</div></div>
            </div>
        </div>
    </div>
    <script>
        class TutorialManager {
            constructor() {
                this.step = 0;
                this.isActive = false;
                this.overlay = document.getElementById('tutorial-overlay');
                this.blob = document.getElementById('tut-blob');
                this.text = document.getElementById('tut-text');
                this.arrow = document.getElementById('tut-arrow');
                this.cursor = document.getElementById('ghost-cursor');
                this.skipBtn = document.getElementById('tut-skip');
                this.ghostDivider = document.getElementById('ghost-divider');

                if(this.skipBtn) {
                    this.skipBtn.addEventListener('click', () => this.toggle());
                }
            }

            init() {
                if (!sessionStorage.getItem('tutorial_seen')) {
                    this.start();
                    sessionStorage.setItem('tutorial_seen', 'true');
                } else {
                    // If seen, show "Tutorial" button but keep overlay hidden
                    this.skipBtn.innerText = "Tutorial";
                    document.body.classList.remove('tutorial-active');
                    this.overlay.style.pointerEvents = 'none'; // Ensure clicks pass through
                }
            }

            toggle() {
                if (this.isActive) {
                    this.complete();
                } else {
                    this.start();
                }
            }

            start() {
                this.isActive = true;
                document.body.classList.add('tutorial-active');
                this.skipBtn.innerText = "Skip Tutorial";
                // this.overlay.style.pointerEvents = 'auto'; // REMOVED: Overlay must be passthrough
                this.showStep(0);
            }

            complete() {
                this.isActive = false;
                document.body.classList.remove('tutorial-active');
                this.skipBtn.innerText = "Tutorial";
                this.overlay.style.pointerEvents = 'none';
            }

            showStep(stepIndex) {
                if (!this.isActive) return;
                this.step = stepIndex;
                this.cursor.style.animation = 'none';
                this.cursor.style.opacity = 0;
                this.ghostDivider.style.opacity = 0;
                this.ghostDivider.style.animation = 'none';

                // Reset cursor icon to pointer
                this.cursor.innerHTML = '<svg viewBox="0 0 24 24" fill="white" stroke="black" stroke-width="2" xmlns="http://www.w3.org/2000/svg"><path d="M3 3L10.07 19.97L12.58 12.58L19.97 10.07L3 3Z" /></svg>';

                if(!this.overlay || !this.blob) return;

                const topView = document.getElementById('view-top-placeholder');
                const getLabel3D = (axis) => {
                    const labels = document.querySelectorAll('.dim-label-3d');
                    for (let el of labels) {
                        const worldPos = JSON.parse(el.dataset.worldPos || '{}');
                        // L is along X (offset Z), W is along Z (offset X), H is Y
                        // Identification logic based on creation code:
                        // L label: pos(0, -h/2-10, w/2+10) -> Approx Z > 0
                        // W label: pos(l/2+15, -h/2-10, 0) -> Approx X > 0
                        // H label: pos(-l/2-15, 0, w/2+15) -> Approx Y approx 0
                        if (axis === 'l' && Math.abs(worldPos.x) < 1 && worldPos.z > 1) return el;
                        if (axis === 'w' && worldPos.x > 1 && Math.abs(worldPos.z) < 1) return el;
                        if (axis === 'h' && Math.abs(worldPos.y) < 1) return el;
                    }
                    return null;
                };

                switch(stepIndex) {
                    case 0: // Set Length
                        this.positionHint(getLabel3D('l') || document.querySelector('.input-group'), 'Set Length', 'left');
                        break;
                    case 1: // Set Width
                        this.positionHint(getLabel3D('w'), 'Set Width', 'right');
                        break;
                    case 2: // Set Height
                        this.positionHint(getLabel3D('h'), 'Set Height', 'top');
                        break;
                    case 3: // Add Horizontal (Add Z) - Right Edge
                        this.positionHint(topView, 'Add Horizontal', 'right-offset');
                        this.playAnimation('cursor-scan-h', topView, 'right-edge-outer');
                        break;
                    case 4: // Add Vertical (Add X) - Bottom Edge
                        this.positionHint(topView, 'Add Vertical', 'bottom-offset');
                        this.playAnimation('cursor-scan-v', topView, 'bottom-edge-outer');
                        break;
                    case 5: // Drag
                        this.positionHint(topView, 'Click & Hold to move', 'bottom');
                        this.playDragAnimation(topView);
                        break;
                    case 6: // Delete
                        this.positionHint(topView, 'Double click to delete', 'bottom');
                        this.playDeleteAnimation(topView);
                        break;
                    default:
                        this.complete();
                }
            }

            positionHint(target, text, side) {
                if(!target) return;
                const rect = target.getBoundingClientRect();
                this.text.innerText = text;

                let top, left, arrowRot, arrowTop, arrowLeft;

                if (side === 'right') {
                    top = rect.top - 20;
                    left = rect.right + 20;
                    arrowRot = 135;
                    arrowTop = rect.top + 10;
                    arrowLeft = rect.right + 5;
                } else if (side === 'right-offset') { // Specific for Horizontal Divider Step
                    top = rect.top + rect.height / 2 - 60;
                    left = rect.right + 10; // 10px offset from right wall
                    arrowRot = 180;
                    arrowTop = rect.top + rect.height / 2 - 30;
                    arrowLeft = rect.right - 10;
                    // Hide arrow for this specific clean look if desired, or keep pointing
                    this.arrow.style.opacity = 0;
                } else if (side === 'bottom-offset') { // Specific for Vertical Divider Step
                    top = rect.bottom + 10;
                    left = rect.left + rect.width / 2 - 70;
                    arrowRot = 270;
                    this.arrow.style.opacity = 0;
                } else if (side === 'left') {
                    top = rect.top - 20;
                    left = rect.left - 160;
                    arrowRot = 45;
                    arrowTop = rect.top + 10;
                    arrowLeft = rect.left - 65;
                } else if (side === 'top') {
                    top = rect.top - 120;
                    left = rect.left - 40;
                    arrowRot = 100;
                    arrowTop = rect.top - 30;
                    arrowLeft = rect.left + 15;
                } else {
                    top = rect.bottom + 60;
                    left = rect.left + rect.width/2 - 70;
                    arrowRot = 45;
                    arrowTop = rect.bottom + 5;
                    arrowLeft = rect.left + rect.width/2 - 30;
                }

                if (side !== 'right-offset' && side !== 'bottom-offset') this.arrow.style.opacity = 1;

                // Boundary checks
                if (left + 140 > window.innerWidth) left = window.innerWidth - 160;
                if (left < 0) left = 10;
                if (top + 100 > window.innerHeight) top = rect.top - 120;

                this.blob.style.top = `${top}px`;
                this.blob.style.left = `${left}px`;

                if (this.arrow.style.opacity !== '0') {
                    this.arrow.style.transform = `rotate(${arrowRot}deg)`;
                    this.arrow.style.top = `${arrowTop}px`;
                    this.arrow.style.left = `${arrowLeft}px`;
                }
            }

            playAnimation(animName, target, edge) {
                if(!target) return;
                const rect = target.getBoundingClientRect();

                if (edge === 'right-edge-outer') {
                    // Start at center-right, outside
                    this.cursor.style.left = `${rect.right + 20}px`;
                    this.cursor.style.top = `${rect.top + rect.height/2 - 75}px`;
                } else if (edge === 'bottom-edge-outer') {
                    // Start at center-bottom, outside
                    this.cursor.style.left = `${rect.left + rect.width/2 - 75}px`;
                    this.cursor.style.top = `${rect.bottom + 20}px`;
                } else if (edge === 'right-edge') {
                    this.cursor.style.left = `${rect.right - 20}px`;
                    this.cursor.style.top = `${rect.top + rect.height/2 - 50}px`;
                } else if (edge === 'bottom-edge') {
                    this.cursor.style.left = `${rect.left + rect.width/2 - 50}px`;
                    this.cursor.style.top = `${rect.bottom - 20}px`;
                } else {
                    this.cursor.style.left = `${rect.left + rect.width/2}px`;
                    this.cursor.style.top = `${rect.top + rect.height/2}px`;
                }

                this.cursor.style.animation = `${animName} 4s infinite`;
            }

            playDragAnimation(target) {
                if(!target) return;
                let startX = 0, startY = 0, isVert = true;
                if (dividersX.length > 0) {
                     const lastX = dividersX[dividersX.length-1];
                     const rect = target.getBoundingClientRect();
                     const aspect = rect.width / rect.height;
                     const rangeX = FRUSTUM_SIZE * aspect;
                     const pctX = (lastX - (-rangeX/2)) / rangeX;
                     startX = rect.left + pctX * rect.width;
                     startY = rect.top + rect.height / 2;
                     isVert = true;
                } else if (dividersZ.length > 0) {
                     const lastZ = dividersZ[dividersZ.length-1];
                     const rect = target.getBoundingClientRect();
                     const pctY = (lastZ / FRUSTUM_SIZE) + 0.5;
                     startX = rect.left + rect.width/2;
                     startY = rect.top + pctY * rect.height;
                     isVert = false;
                } else {
                    const rect = target.getBoundingClientRect();
                    startX = rect.left + rect.width/2;
                    startY = rect.top + rect.height/2;
                }

                this.cursor.style.left = `${startX}px`;
                this.cursor.style.top = `${startY}px`;

                this.cursor.innerHTML = '<svg viewBox="0 0 24 24" fill="white" stroke="black" stroke-width="2" xmlns="http://www.w3.org/2000/svg"><path d="M18 11V6a2 2 0 0 0-2-2 2 2 0 0 0-2 2v1h-1V4a2 2 0 0 0-2-2 2 2 0 0 0-2 2v3h-1V2a2 2 0 0 0-2-2 2 2 0 0 0-2 2v5h-1V5a2 2 0 0 0-2-2 2 2 0 0 0-2 2v6c0 4.418 3.582 8 8 8s8-3.582 8-8z" /></svg>';
                this.cursor.style.animation = 'cursor-drag-shadow 4s infinite';

                this.ghostDivider.style.left = `${startX}px`;
                this.ghostDivider.style.top = `${startY}px`;
                if(isVert) {
                    this.ghostDivider.style.width = '4px';
                    this.ghostDivider.style.height = '100px';
                } else {
                    this.ghostDivider.style.width = '100px';
                    this.ghostDivider.style.height = '4px';
                }
                this.ghostDivider.style.opacity = 0;
                this.ghostDivider.style.animation = 'divider-drag-shadow 4s infinite';
            }

            playDeleteAnimation(target) {
                 if(!target) return;
                 let startX = 0, startY = 0;
                 if (dividersX.length > 0) {
                     const lastX = dividersX[dividersX.length-1];
                     const rect = target.getBoundingClientRect();
                     const aspect = rect.width / rect.height;
                     const rangeX = FRUSTUM_SIZE * aspect;
                     const pctX = (lastX - (-rangeX/2)) / rangeX;
                     startX = rect.left + pctX * rect.width;
                     startY = rect.top + rect.height / 2;
                } else if (dividersZ.length > 0) {
                     const lastZ = dividersZ[dividersZ.length-1];
                     const rect = target.getBoundingClientRect();
                     const pctY = (lastZ / FRUSTUM_SIZE) + 0.5;
                     startX = rect.left + rect.width/2;
                     startY = rect.top + pctY * rect.height;
                } else {
                    const rect = target.getBoundingClientRect();
                    startX = rect.left + rect.width/2; startY = rect.top + rect.height/2;
                }

                this.cursor.style.left = `${startX}px`;
                this.cursor.style.top = `${startY}px`;
                this.cursor.style.animation = 'cursor-click-delete-slow 4s infinite';
            }

            advanceFrom(stepIndex) {
                if (this.isActive && this.step === stepIndex) {
                    this.showStep(stepIndex + 1);
                }
            }
        }
        const tutorial = new TutorialManager();

        lucide.createIcons();
        let scene, renderer, boxGroup, camera3D, cameraTop;
        const canvas = document.getElementById('main-canvas'), view3D = document.getElementById('view-3d-placeholder'), viewTop = document.getElementById('view-top-placeholder'), dimContainer = document.getElementById('dim-container'), dimContainer3D = document.getElementById('dim-container-3d'), indicator = document.getElementById('add-indicator'), previewLine = document.getElementById('preview-line'), globalInput = document.getElementById('global-dim-input');
        let dividersX = [], dividersZ = [], hiddenSegments = {}, pendingAction = null, draggingDivider = null, selectedForRemoval = null, isEditing = false, currentEditCallback = null;
        let FRUSTUM_SIZE = 250;
        let lastZoomedMaxDim = 0;

        function autoFitCamera() {
            const l = parseFloat(document.getElementById('dim-l').value) || 120;
            const w = parseFloat(document.getElementById('dim-w').value) || 120;
            const h = parseFloat(document.getElementById('dim-h').value) || 40;
            const maxDim = Math.max(l, w, h);

            // Fit Top View
            const rectTop = viewTop.getBoundingClientRect();
            if (rectTop.height > 0) {
                const aspect = rectTop.width / rectTop.height;
                // Fit width (L) or height (W) with 10% padding (factor 1.2 total scale relative to content)
                FRUSTUM_SIZE = Math.max(w, l / aspect) * 1.2;

                // Update cameraTop immediately
                if (cameraTop) {
                    cameraTop.left = FRUSTUM_SIZE * aspect / -2;
                    cameraTop.right = FRUSTUM_SIZE * aspect / 2;
                    cameraTop.top = FRUSTUM_SIZE / 2;
                    cameraTop.bottom = FRUSTUM_SIZE / -2;
                    cameraTop.updateProjectionMatrix();
                }
            }

            // Fit 3D View
            const rect3D = view3D.getBoundingClientRect();
            if (rect3D.height > 0) {
                const aspect3D = rect3D.width / rect3D.height;
                const fovRad = (camera3D.fov * Math.PI) / 180;

                // Calculate distance needed to fit the object vertically
                // Object size roughly maxDim. We want margin.
                const verticalSize = maxDim * 1.4;
                let distance = (verticalSize / 2) / Math.tan(fovRad / 2);

                // Check horizontal fit
                const horizontalSize = maxDim * 1.4;
                const distanceH = (horizontalSize / 2) / (Math.tan(fovRad / 2) * aspect3D);

                distance = Math.max(distance, distanceH);

                // Current direction vector normalized (approx 1,1,1)
                const direction = new THREE.Vector3(1, 1, 1).normalize();
                camera3D.position.copy(direction.multiplyScalar(distance));
                camera3D.lookAt(0, 0, 0);
            }

            lastZoomedMaxDim = maxDim;
        }

        function checkAutoZoom() {
            const l = parseFloat(document.getElementById('dim-l').value) || 120;
            const w = parseFloat(document.getElementById('dim-w').value) || 120;
            const h = parseFloat(document.getElementById('dim-h').value) || 40;
            const currentMaxDim = Math.max(l, w, h);

            if (lastZoomedMaxDim === 0) {
                autoFitCamera();
            } else {
                const diff = Math.abs(currentMaxDim - lastZoomedMaxDim);
                if (diff / lastZoomedMaxDim > 0.05) {
                    autoFitCamera();
                }
            }
        }

        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x1a1a1a);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true }); renderer.setPixelRatio(window.devicePixelRatio);
            camera3D = new THREE.PerspectiveCamera(40, 1, 1, 1000); camera3D.position.set(160, 160, 160); camera3D.lookAt(0, 0, 0);
            cameraTop = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 1000); cameraTop.position.set(0, 200, 0); cameraTop.lookAt(0, 0, 0);
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6); scene.add(ambientLight);
            const spotLight = new THREE.SpotLight(0xfff5e6, 1.0); spotLight.position.set(100, 250, 100); scene.add(spotLight);
            const dirLight = new THREE.DirectionalLight(0xd4d4d8, 0.4); dirLight.position.set(-100, 100, -50); scene.add(dirLight);
            boxGroup = new THREE.Group(); scene.add(boxGroup);
            let isDragging3D = false, prevX3D = 0;
            view3D.addEventListener('mousedown', (e) => { if (isEditing) return; if (e.target.closest('.dim-label')) return; isDragging3D = true; prevX3D = e.clientX; });
            window.addEventListener('mouseup', () => { isDragging3D = false; });
            window.addEventListener('mousemove', (e) => { if (isDragging3D && !isEditing) { boxGroup.rotation.y += (e.clientX - prevX3D) * 0.01; prevX3D = e.clientX; } });
            viewTop.addEventListener('mousedown', onTopMouseDown); viewTop.addEventListener('mousemove', onTopMouseMove); window.addEventListener('mouseup', onTopMouseUp);
            document.getElementById('clear-dividers').addEventListener('click', () => { dividersX = []; dividersZ = []; hiddenSegments = {}; updateBox(); });
            document.getElementById('export-btn').addEventListener('click', exportSTL);
            const dimL = document.getElementById('dim-l');
            const dimW = document.getElementById('dim-w');
            const dimH = document.getElementById('dim-h');

            dimL.addEventListener('input', () => { if(!isEditing) updateBox(); tutorial.advanceFrom(0); });
            dimL.addEventListener('change', checkAutoZoom);

            dimW.addEventListener('input', () => { if(!isEditing) updateBox(); tutorial.advanceFrom(1); });
            dimW.addEventListener('change', checkAutoZoom);

            dimH.addEventListener('input', () => { if(!isEditing) updateBox(); tutorial.advanceFrom(2); });
            dimH.addEventListener('change', checkAutoZoom);
            document.getElementById('radius').addEventListener('input', (e) => { updateBox(); });
            setupGlobalInput(); updateBox(); autoFitCamera(); animate();
            tutorial.init();
        }

        // Logic xuất file STL
        function exportSTL() {
            const exporter = new THREE.STLExporter();
            // Tạm thời reset xoay về 0 để file xuất ra thẳng hàng với trục toạ độ
            const currentRotation = boxGroup.rotation.y;
            boxGroup.rotation.y = 0;
            boxGroup.updateMatrixWorld();

            const result = exporter.parse(boxGroup, { binary: true });

            // Khôi phục lại góc xoay
            boxGroup.rotation.y = currentRotation;
            boxGroup.updateMatrixWorld();

            const blob = new Blob([result], { type: 'application/octet-stream' });
            const link = document.createElement('a');
            link.style.display = 'none';
            document.body.appendChild(link);
            link.href = URL.createObjectURL(blob);

            // Đặt tên file theo kích thước
            const l = document.getElementById('dim-l').value;
            const w = document.getElementById('dim-w').value;
            const h = document.getElementById('dim-h').value;
            link.download = `BentoBox_${l}x${w}x${h}.stl`;

            link.click();
            document.body.removeChild(link);
        }

        function createRoundedRectShape(w, h, r) {
            const ctx = new THREE.Shape(); const x = -w/2, y = -h/2; const radius = Math.min(r, Math.min(w, h)/2);
            ctx.moveTo(x + radius, y); ctx.lineTo(x + w - radius, y); ctx.quadraticCurveTo(x + w, y, x + w, y + radius); ctx.lineTo(x + w, y + h - radius); ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h); ctx.lineTo(x + radius, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - radius); ctx.lineTo(x, y + radius); ctx.quadraticCurveTo(x, y, x + radius, y); return ctx;
        }

        function createAdaptiveHoleShape(x, z, w, h, radii) {
            const shape = new THREE.Shape(); const startX = x - w/2, startY = z - h/2;
            const r_br = Math.min(radii[2], Math.min(w, h)/2), r_tr = Math.min(radii[1], Math.min(w, h)/2), r_tl = Math.min(radii[0], Math.min(w, h)/2), r_bl = Math.min(radii[3], Math.min(w, h)/2);
            shape.moveTo(startX + r_bl, startY); shape.lineTo(startX + w - r_br, startY); shape.quadraticCurveTo(startX + w, startY, startX + w, startY + r_br); shape.lineTo(startX + w, startY + h - r_tr); shape.quadraticCurveTo(startX + w, startY + h, startX + w - r_tr, startY + h); shape.lineTo(startX + r_tl, startY + h); shape.quadraticCurveTo(startX, startY + h, startX, startY + h - r_tl); shape.lineTo(startX, startY + r_bl); shape.quadraticCurveTo(startX, startY, startX + r_bl, startY); return shape;
        }

        function setupGlobalInput() { globalInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') finishEditing(); else if (e.key === 'Escape') cancelEditing(); }); globalInput.addEventListener('blur', () => setTimeout(finishEditing, 100)); globalInput.addEventListener('mousedown', (e) => e.stopPropagation()); }
        function startEditing(x, y, val, cb) { isEditing = true; currentEditCallback = cb; globalInput.style.display = 'block'; globalInput.style.left = `${x}px`; globalInput.style.top = `${y}px`; globalInput.value = val; globalInput.focus(); globalInput.select(); }
        function finishEditing() { if (!isEditing) return; const val = parseFloat(globalInput.value); if (!isNaN(val) && currentEditCallback) currentEditCallback(val); isEditing = false; globalInput.style.display = 'none'; currentEditCallback = null; updateBox(); }
        function cancelEditing() { isEditing = false; globalInput.style.display = 'none'; currentEditCallback = null; }

        function getTopWorldCoords(e) { const rect = viewTop.getBoundingClientRect(); const x = e.clientX - rect.left, y = e.clientY - rect.top; const mouseX = (x / rect.width) * 2 - 1, mouseY = -(y / rect.height) * 2 + 1, aspect = rect.width / rect.height; return { x: mouseX * (FRUSTUM_SIZE * aspect / 2), z: -mouseY * (FRUSTUM_SIZE / 2), isInside: x >= 0 && x <= rect.width && y >= 0 && y <= rect.height }; }

        function onTopMouseDown(e) {
            if (e.target.closest('.dim-label')) return; if (isEditing) return;
            const world = getTopWorldCoords(e); if (!world.isInside) return;
            const l = parseFloat(document.getElementById('dim-l').value), w = parseFloat(document.getElementById('dim-w').value), hitMargin = 10;
            let hit = null;
            for (let i = 0; i < dividersX.length; i++) { if (Math.abs(world.x - dividersX[i]) < hitMargin && Math.abs(world.z) < w/2) { const sortedZ = [-w/2, ...[...dividersZ].sort((a,b)=>a-b), w/2]; let segIdx = 0; for(let j=0; j<sortedZ.length-1; j++) { if(world.z >= sortedZ[j] && world.z <= sortedZ[j+1]) { segIdx = j; break; } } hit = { type: 'X', index: i, segment: segIdx }; break; } }
            if (!hit) { for (let i = 0; i < dividersZ.length; i++) { if (Math.abs(world.z - dividersZ[i]) < hitMargin && Math.abs(world.x) < l/2) { const sortedX = [-l/2, ...[...dividersX].sort((a,b)=>a-b), l/2]; let segIdx = 0; for(let j=0; j<sortedX.length-1; j++) { if(world.x >= sortedX[j] && world.x <= sortedX[j+1]) { segIdx = j; break; } } hit = { type: 'Z', index: i, segment: segIdx }; break; } } }
            if (hit) { draggingDivider = { ...hit, hasMoved: false }; viewTop.classList.add('cursor-grabbing'); } else { if (selectedForRemoval) { selectedForRemoval = null; updateBox(); } if (pendingAction && (pendingAction.type === 'addX' || pendingAction.type === 'addZ')) {
                if (pendingAction.type === 'addX') {
                    dividersX.push(pendingAction.pos);
                    tutorial.advanceFrom(4); // Step 4 (Vertical instruction) -> Step 5
                } else {
                    dividersZ.push(pendingAction.pos);
                    tutorial.advanceFrom(3); // Step 3 (Horizontal instruction) -> Step 4
                }
                updateBox();
            } }
        }

        function onTopMouseMove(e) {
            if (isEditing) return; const world = getTopWorldCoords(e); const l = parseFloat(document.getElementById('dim-l').value), w = parseFloat(document.getElementById('dim-w').value), rect = viewTop.getBoundingClientRect(), aspect = rect.width / rect.height;
            if (draggingDivider) { draggingDivider.hasMoved = true; if (draggingDivider.type === 'X') dividersX[draggingDivider.index] = Math.max(-l/2 + 5, Math.min(l/2 - 5, world.x)); else dividersZ[draggingDivider.index] = Math.max(-w/2 + 5, Math.min(w/2 - 5, world.z)); updateBox(); indicator.style.left = `${e.clientX-18}px`; indicator.style.top = `${e.clientY-18}px`; indicator.innerText = '↔'; indicator.className = 'active move'; return; }
            if (!world.isInside) { indicator.classList.remove('active'); previewLine.style.display = 'none'; return; }
            const hitMargin = 10, edgeMargin = 35; let hit = null;
            for (let i = 0; i < dividersX.length; i++) { if (Math.abs(world.x - dividersX[i]) < hitMargin && Math.abs(world.z) < w/2) { const sortedZ = [-w/2, ...[...dividersZ].sort((a,b)=>a-b), w/2]; for(let j=0; j<sortedZ.length-1; j++) { if(world.z >= sortedZ[j] && world.z <= sortedZ[j+1]) { hit = { type: 'X', index: i, segment: j }; break; } } break; } }
            if (!hit) { for (let i = 0; i < dividersZ.length; i++) { if (Math.abs(world.z - dividersZ[i]) < hitMargin && Math.abs(world.x) < l/2) { const sortedX = [-l/2, ...[...dividersX].sort((a,b)=>a-b), l/2]; for(let j=0; j<sortedX.length-1; j++) { if(world.x >= sortedX[j] && world.x <= sortedX[j+1]) { hit = { type: 'Z', index: i, segment: j }; break; } } break; } } }
            if (hit) { pendingAction = { type: 'remove', axis: hit.type, lineIdx: hit.index, segIdx: hit.segment }; const isConfirming = selectedForRemoval && selectedForRemoval.axis === hit.type && selectedForRemoval.lineIdx === hit.index && selectedForRemoval.segIdx === hit.segment; indicator.style.left = `${e.clientX-18}px`; indicator.style.top = `${e.clientY-18}px`; indicator.innerText = '-'; indicator.className = 'active' + (isConfirming ? ' remove-confirm' : ' move'); previewLine.style.display = 'none'; }
            else { const isInsideW = Math.abs(world.x) < (l/2 - 5), isNearH = Math.abs(world.z - w/2) < edgeMargin || Math.abs(world.z + w/2) < edgeMargin, isInsideD = Math.abs(world.z) < (w/2 - 5), isNearV = Math.abs(world.x - l/2) < edgeMargin || Math.abs(world.x + l/2) < edgeMargin; if (isNearH && isInsideW) { pendingAction = { type: 'addX', pos: world.x }; indicator.innerText = '+'; indicator.className = 'active'; previewLine.style.display = 'block'; previewLine.style.width = '2px'; previewLine.style.height = `${(w/FRUSTUM_SIZE)*rect.height}px`; previewLine.style.left = `${e.clientX-1}px`; previewLine.style.top = `${rect.top + rect.height/2 - (w/FRUSTUM_SIZE)*rect.height/2}px`; } else if (isNearV && isInsideD) { pendingAction = { type: 'addZ', pos: world.z }; indicator.innerText = '+'; indicator.className = 'active'; previewLine.style.display = 'block'; previewLine.style.height = '2px'; previewLine.style.width = `${(l/FRUSTUM_SIZE)*aspect*rect.width}px`; previewLine.style.top = `${e.clientY-1}px`; previewLine.style.left = `${rect.left + rect.width/2 - (l/FRUSTUM_SIZE)*aspect*rect.width/2}px`; } else { indicator.classList.remove('active'); previewLine.style.display = 'none'; pendingAction = null; } indicator.style.left = `${e.clientX-18}px`; indicator.style.top = `${e.clientY-18}px`; }
        }

        function onTopMouseUp() {
            viewTop.classList.remove('cursor-grabbing');
            if (draggingDivider) {
                if (!draggingDivider.hasMoved) {
                    const hit = { axis: draggingDivider.type, lineIdx: draggingDivider.index, segIdx: draggingDivider.segment };
                    if (selectedForRemoval && selectedForRemoval.axis === hit.axis && selectedForRemoval.lineIdx === hit.lineIdx && selectedForRemoval.segIdx === hit.segIdx) {
                        const key = `${hit.axis}_${hit.lineIdx}_${hit.segIdx}`;
                        hiddenSegments[key] = true;
                        selectedForRemoval = null;
                        cleanupDividers();
                        updateBox();
                        tutorial.advanceFrom(6); // Step 6 (Delete) -> Finish
                    } else {
                        selectedForRemoval = hit;
                        updateBox();
                    }
                } else {
                    selectedForRemoval = null;
                    if (draggingDivider.hasMoved) tutorial.advanceFrom(5); // Step 5 (Drag) -> Step 6
                }
                draggingDivider = null;
            }
        }

        function cleanupDividers() {
            let changed = true;
            while(changed) {
                changed = false;
                // Check X dividers
                for(let i=0; i<dividersX.length; i++) {
                    let allHidden = true;
                    for(let j=0; j <= dividersZ.length; j++) {
                        if(!hiddenSegments[`X_${i}_${j}`]) { allHidden = false; break; }
                    }
                    if(allHidden) {
                        const val = dividersX[i];
                        const sortedX = [...dividersX].sort((a,b)=>a-b);
                        const spatialIdx = sortedX.indexOf(val);

                        dividersX.splice(i, 1);
                        hiddenSegments = updateHiddenSegmentsMap('X', i, spatialIdx);
                        changed = true;
                        break;
                    }
                }
                if(changed) continue;

                // Check Z dividers
                for(let i=0; i<dividersZ.length; i++) {
                    let allHidden = true;
                    for(let j=0; j <= dividersX.length; j++) {
                        if(!hiddenSegments[`Z_${i}_${j}`]) { allHidden = false; break; }
                    }
                    if(allHidden) {
                        const val = dividersZ[i];
                        const sortedZ = [...dividersZ].sort((a,b)=>a-b);
                        const spatialIdx = sortedZ.indexOf(val);

                        dividersZ.splice(i, 1);
                        hiddenSegments = updateHiddenSegmentsMap('Z', i, spatialIdx);
                        changed = true;
                        break;
                    }
                }
            }
        }

        function updateHiddenSegmentsMap(removedAxis, removedArrayIndex, removedSpatialIndex) {
            const newHidden = {};
            for (let key in hiddenSegments) {
                const parts = key.split('_');
                const axis = parts[0];
                const lineIdx = parseInt(parts[1]);
                const segIdx = parseInt(parts[2]);

                if (axis === removedAxis) {
                    // Same axis: shift lineIdx based on Array Index
                    if (lineIdx < removedArrayIndex) {
                        newHidden[key] = true;
                    } else if (lineIdx > removedArrayIndex) {
                        newHidden[`${axis}_${lineIdx - 1}_${segIdx}`] = true;
                    }
                } else {
                    // Perpendicular axis: shift segIdx based on Spatial Index
                    if (segIdx < removedSpatialIndex) {
                        newHidden[key] = true;
                    } else if (segIdx > removedSpatialIndex + 1) {
                        newHidden[`${axis}_${lineIdx}_${segIdx - 1}`] = true;
                    }
                }
            }
            return newHidden;
        }

        function getMinSegmentSize(totalSize, dividers) {
            const points = [-totalSize/2, ...[...dividers].sort((a,b)=>a-b), totalSize/2];
            let minSize = totalSize;
            for(let i = 0; i < points.length - 1; i++) {
                const dist = points[i+1] - points[i];
                if (dist < minSize) minSize = dist;
            }
            return minSize;
        }

        function updateBox() {
            while(boxGroup.children.length > 0) boxGroup.remove(boxGroup.children[0]);

            const l = parseFloat(document.getElementById('dim-l').value)||120;
            const w = parseFloat(document.getElementById('dim-w').value)||120;
            const h = parseFloat(document.getElementById('dim-h').value)||40;
            const inputR = parseFloat(document.getElementById('radius').value)||8;

            dividersX = dividersX.filter(x => Math.abs(x) < l/2 - 5);
            dividersZ = dividersZ.filter(z => Math.abs(z) < w/2 - 5);

            // Logic mới để giới hạn radius
            const minSegX = getMinSegmentSize(l, dividersX);
            const minSegZ = getMinSegmentSize(w, dividersZ);
            const minSegment = Math.min(minSegX, minSegZ);

            // Radius an toàn = 1/2 đoạn nhỏ nhất - 0.5mm
            const maxSafeRadius = (minSegment / 2) - 0.5;

            // Giới hạn bán kính thực tế (r) sử dụng cho model, tối thiểu là 1
            const effectiveR = Math.max(1, Math.min(inputR, maxSafeRadius));

            // Cập nhật text hiển thị để người dùng biết giá trị thực tế đang dùng
            document.getElementById('radius-val').innerText = `${Math.round(effectiveR * 10) / 10}mm`;

            boxGroup.add(createModel(l, h, w, effectiveR, dividersX, dividersZ));
            updateDimensions();
        }

        function createEditableLabel(text, cb) { const el = document.createElement('div'); el.className = 'dim-label'; el.innerText = text; el.addEventListener('mousedown', (e) => { e.stopPropagation(); e.preventDefault(); const r = el.getBoundingClientRect(); startEditing(r.left + r.width/2, r.top + r.height/2, text, cb); }); return el; }

        function createModel(l, h, w, r, dX, dZ) {
            const group = new THREE.Group();
            const matWall = new THREE.MeshPhongMaterial({ color: 0xe5d3b3, shininess: 30, specular: 0x111111 });
            const matBase = new THREE.MeshPhongMaterial({ color: 0x6f4e37, shininess: 5, specular: 0x000000 }); // Warm Cork/Wood
            const thick = 2, outerShape = createRoundedRectShape(l, w, r);
            const sortedX = [-l/2, ...[...dX].sort((a,b)=>a-b), l/2], sortedZ = [-w/2, ...[...dZ].sort((a,b)=>a-b), w/2], visited = new Set(), rooms = [];
            const getCellId = (i, j) => `${i},${j}`;
            for(let i=0; i<sortedX.length-1; i++) {
                for(let j=0; j<sortedZ.length-1; j++) {
                    if(visited.has(getCellId(i,j))) continue;
                    let roomCells = [], queue = [{i, j}]; visited.add(getCellId(i,j));
                    let minI=i, maxI=i, minJ=j, maxJ=j;
                    while(queue.length > 0) {
                        const curr = queue.pop(); roomCells.push(curr);
                        minI = Math.min(minI, curr.i); maxI = Math.max(maxI, curr.i); minJ = Math.min(minJ, curr.j); maxJ = Math.max(maxJ, curr.j);
                        [[1,0,'X'],[-1,0,'X'],[0,1,'Z'],[0,-1,'Z']].forEach(d => {
                            const ni = curr.i + d[0], nj = curr.j + d[1];
                            if(ni >= 0 && ni < sortedX.length-1 && nj >= 0 && nj < sortedZ.length-1) {
                                let hasWall = true;
                                if(d[2] === 'X') { const wallIdx = Math.max(curr.i, ni), rawIdx = dX.indexOf(sortedX[wallIdx]); if(rawIdx !== -1 && hiddenSegments[`X_${rawIdx}_${Math.min(curr.j, nj)}`]) hasWall = false; }
                                else { const wallIdx = Math.max(curr.j, nj), rawIdx = dZ.indexOf(sortedZ[wallIdx]); if(rawIdx !== -1 && hiddenSegments[`Z_${rawIdx}_${Math.min(curr.i, ni)}`]) hasWall = false; }
                                if(!hasWall && !visited.has(getCellId(ni,nj))) { visited.add(getCellId(ni,nj)); queue.push({i: ni, j: nj}); }
                            }
                        });
                    }
                    rooms.push({bounds: {minI, maxI, minJ, maxJ}});
                }
            }
            rooms.forEach(room => {
                const xStart = sortedX[room.bounds.minI], xEnd = sortedX[room.bounds.maxI + 1], zStart = sortedZ[room.bounds.minJ], zEnd = sortedZ[room.bounds.maxJ + 1];
                const roomW = xEnd - xStart, roomH = zEnd - zStart, centerX = xStart + roomW/2, centerZ = zStart + roomH/2;
                const holeW = roomW - thick, holeH = roomH - thick;
                if(holeW > 0 && holeH > 0) {
                    const touchingL = Math.abs(xStart - (-l/2)) < 0.1, touchingR = Math.abs(xEnd - (l/2)) < 0.1, touchingT = Math.abs(zStart - (-w/2)) < 0.1, touchingB = Math.abs(zEnd - (w/2)) < 0.1;
                    const stdR = 4, bigR = Math.max(stdR, r - thick);
                    const radii = [
                        (touchingL && touchingT) ? bigR : (touchingL || touchingT ? bigR : stdR), // TL
                        (touchingR && touchingT) ? bigR : (touchingR || touchingT ? bigR : stdR), // TR
                        (touchingR && touchingB) ? bigR : (touchingR || touchingB ? bigR : stdR), // BR
                        (touchingL && touchingB) ? bigR : (touchingL || touchingB ? bigR : stdR)  // BL
                    ];
                    outerShape.holes.push(createAdaptiveHoleShape(centerX, centerZ, holeW, holeH, radii));
                }
            });
            const geo = new THREE.ExtrudeGeometry(outerShape, { depth: h, bevelEnabled: false, curveSegments: 24 }); geo.rotateX(Math.PI / 2);
            const mesh = new THREE.Mesh(geo, matWall); mesh.position.y = -h/2 + h;
            const baseShape = createRoundedRectShape(l, w, r), baseGeo = new THREE.ExtrudeGeometry(baseShape, { depth: 2, bevelEnabled: false, curveSegments: 24 }); baseGeo.rotateX(Math.PI / 2);
            const base = new THREE.Mesh(baseGeo, matBase); base.position.y = -h/2 + 2; group.add(mesh); group.add(base); return group;
        }

        function updateDimensions() {
            if (isEditing) return; dimContainer.innerHTML = ''; dimContainer3D.innerHTML = '';
            const rect = viewTop.getBoundingClientRect(), aspect = rect.width / rect.height, l = parseFloat(document.getElementById('dim-l').value), w = parseFloat(document.getElementById('dim-w').value), h = parseFloat(document.getElementById('dim-h').value);
            const w2pX = (wx) => rect.width/2 + (wx / (FRUSTUM_SIZE * aspect / 2)) * (rect.width/2), w2pZ = (wz) => rect.height/2 + (wz / (FRUSTUM_SIZE / 2)) * (rect.height/2);
            const sortedX = [-l/2, ...[...dividersX].sort((a,b) => a-b), l/2];
            for(let i=0; i < sortedX.length - 1; i++) { const dist = sortedX[i+1] - sortedX[i]; if(dist < 1) continue; const el = createEditableLabel(Math.round(dist), (nd) => { const diff = nd - dist; for(let k=0; k<dividersX.length; k++) if(dividersX[k] >= sortedX[i+1] - 0.1) dividersX[k] += diff; }); el.style.left = `${w2pX((sortedX[i] + sortedX[i+1]) / 2)}px`; el.style.top = `${w2pZ(-w/2) - 25}px`; el.style.transform = 'translateX(-50%)'; dimContainer.appendChild(el); }
            const sortedZ = [-w/2, ...[...dividersZ].sort((a,b) => a-b), w/2];
            for(let i=0; i < sortedZ.length - 1; i++) { const dist = sortedZ[i+1] - sortedZ[i]; if(dist < 1) continue; const el = createEditableLabel(Math.round(dist), (nd) => { const diff = nd - dist; for(let k=0; k<dividersZ.length; k++) if(dividersZ[k] >= sortedZ[i+1] - 0.1) dividersZ[k] += diff; }); el.style.left = `${w2pX(-l/2) - 35}px`; el.style.top = `${w2pZ((sortedZ[i] + sortedZ[i+1]) / 2)}px`; el.style.transform = 'translateY(-50%)'; dimContainer.appendChild(el); }
            const labels3D = [ { text: Math.round(l), pos: new THREE.Vector3(0, -h/2 - 10, w/2 + 10), target: 'dim-l' }, { text: Math.round(w), pos: new THREE.Vector3(l/2 + 15, -h/2 - 10, 0), target: 'dim-w' }, { text: Math.round(h), pos: new THREE.Vector3(-l/2 - 15, 0, w/2 + 15), target: 'dim-h' } ];
            labels3D.forEach((info, index) => { const el = createEditableLabel(info.text, (nv) => { document.getElementById(info.target).value = nv; checkAutoZoom(); setTimeout(() => tutorial.advanceFrom(index), 100); }); el.classList.add('dim-label-3d'); el.dataset.worldPos = JSON.stringify(info.pos); dimContainer3D.appendChild(el); });
            document.getElementById('divider-stats').innerText = `Vert: ${dividersX.length} | Horiz: ${dividersZ.length}`;
        }

        function update3DLabels() {
            if (isEditing) return; const rect3D = view3D.getBoundingClientRect(), labels = dimContainer3D.querySelectorAll('.dim-label-3d');
            labels.forEach(el => { if (el.querySelector('input')) return; const worldPos = JSON.parse(el.dataset.worldPos), vector = new THREE.Vector3(worldPos.x, worldPos.y, worldPos.z); vector.applyQuaternion(boxGroup.quaternion); vector.project(camera3D); const x = (vector.x * 0.5 + 0.5) * rect3D.width, y = (-(vector.y) * 0.5 + 0.5) * rect3D.height; if (vector.z < 1) { el.style.display = 'block'; el.style.left = `${x}px`; el.style.top = `${y}px`; el.style.transform = 'translate(-50%, -50%)'; } else { el.style.display = 'none'; } });
        }

        function animate() {
            requestAnimationFrame(animate); const width = canvas.clientWidth, height = canvas.clientHeight; if (canvas.width !== width || canvas.height !== height) { renderer.setSize(width, height, false); updateDimensions(); } renderer.setScissorTest(true);
            const rect3D = view3D.getBoundingClientRect(); renderer.setViewport(rect3D.left, height - rect3D.bottom, rect3D.width, rect3D.height); renderer.setScissor(rect3D.left, height - rect3D.bottom, rect3D.width, rect3D.height); camera3D.aspect = rect3D.width / rect3D.height; camera3D.updateProjectionMatrix(); renderer.render(scene, camera3D); update3DLabels();
            const curRot = boxGroup.rotation.y; boxGroup.rotation.y = 0; boxGroup.updateMatrixWorld();
            const rectTop = viewTop.getBoundingClientRect(); renderer.setViewport(rectTop.left, height - rectTop.bottom, rectTop.width, rectTop.height); renderer.setScissor(rectTop.left, height - rectTop.bottom, rectTop.width, rectTop.height); const aspectTop = rectTop.width / rectTop.height; cameraTop.left = FRUSTUM_SIZE * aspectTop / -2; cameraTop.right = FRUSTUM_SIZE * aspectTop / 2; cameraTop.top = FRUSTUM_SIZE / 2; cameraTop.bottom = FRUSTUM_SIZE / -2; cameraTop.updateProjectionMatrix(); renderer.render(scene, cameraTop);
            boxGroup.rotation.y = curRot; boxGroup.updateMatrixWorld();
        }
        window.onload = init;
    </script>
</body>
</html>